main: () = {
  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      // Condition is `false_type` for `int`, alternative not instantiated.
      is std::string = x.substr(0);
      is _           = true;
    }]]
  }(1);

  {
    pred := :<T> (y: T) -> std::true_type = {
      std::terminate();
      return ();
    };
    [[assert Testing: inspect 1 -> bool {
      // Condition is `true_type` for `int`, statement unconditionally executed.
      is (pred) = true;
      is _      = false;
    }]]
  }

  _ = :(x) = {
    pred := :<T> (y: T) -> bool requires std::is_same_v<T, long> = {
      std::terminate();
      return true;
    };
    [[assert Testing: inspect x -> bool {
      // Condition is non-viable for `int`, alternative not instantiated.
      is (pred) = x.substr(0);
      is _      = true;
    }]]
  }(1);

  // Exercise all built-in `is` overloads.

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is std::vector          = x.substr(0);
      is std::array           = x.substr(0);
      is std::string          = x.substr(0);
      is std::exception       = x.substr(0);
      is cpp2::empty          = x.substr(0);
      is (std::ranges::empty) = x.substr(0);
      is ("")                 = x.substr(0);
      is _                    = true;
    }]]
  }(1);
  _ = :(x) = {
    [[assert Testing: inspect x& -> bool {
      is std::exception = x.substr(0);
      is _              = true;
    }]]
  }(1);

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is std::vector = true;
      is _           = false;
    }]]
  }(:std::vector = (1));

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is std::array = true;
      is _          = false;
    }]]
  }(:std::array = (1));

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is int = true;
      is _   = false;
    }]]
  }(1);

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      // FIXME
      // Using `std::ranges::subrange<std::add_pointer_t<i32>>::view_interface` fails.
      // The alternative is elided due to the `is` being ambiguous.
      // Like in P2392, the cases of the built-in `is` should be a chain of conditions.
      // Using overloads to implement that is tedious and error-prone.
      is std::ranges::view_interface<std::ranges::subrange<std::add_pointer_t<i32>>> = true;
      is _                                                                           = false;
    }]]
  }(:std::ranges::subrange<std::add_pointer_t<i32>> = ());

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is std::exception = true;
      is _              = false;
    }]]
  }(:std::bad_exception = ());

  _ = :(x) = {
    [[assert Testing: inspect x& -> bool {
      is std::exception = true;
      is _              = false;
    }]]
  }(:std::bad_exception = ());

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is cpp2::empty = true;
      is _           = false;
    }]]
  }(:std::optional<i32> = ());

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is (std::ranges::empty) = true;
      is _                    = false;
    }]]
  }(:std::vector<i32> = ());

  _ = :(x) = {
    [[assert Testing: inspect x -> bool {
      is (1) = true;
      is _   = false;
    }]]
  }(1);

  // Exercise `is` overloads for `std::` types.

  {
    f := :(x) = {
      (pred := :<T> (y: T) -> bool requires std::is_same_v<T, i32> = {
        std::terminate();
        return true;
      })
        [[assert Testing: inspect x -> bool {
          is (:std::span<i32> = ()) = x.substr(0);
          is (pred)                 = x.substr(0);
          is (1)                    = true;
          is _                      = false;
        }]]

      (pred := :<T> (y: T) -> std::true_type = {
        std::terminate();
        return ();
      }) {
        [[assert Testing: inspect x -> bool {
          is (pred) = true;
          is _      = false;
        }]]
      }
    };
    f(:std::any      = 1);
    f(:std::optional = 1);
  }
}
